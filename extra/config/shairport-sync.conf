// Sample Configuration File for Shairport Sync
// Commented out settings are generally the defaults, except where noted.
// Some sections are operative only if Shairport Sync has been built with the right configuration flags.
// See the individual sections for details.

// General Settings
general =
{
	name = "%H"; // This means "Hostname" -- see below. This is the name the service will advertise to iTunes.

	interpolation = "auto"; // aka "stuffing". Default is "auto". Alternatives are "basic" or "soxr". Choose "soxr" only if you have a reasonably fast processor and Shairport Sync has been built with "soxr" support.
	output_backend = "dummy"; // Run "shairport-sync -h" to get a list of all output_backends, e.g. "alsa", "pipe", "stdout". The default is the first one.
	mdns_backend = "avahi"; // Run "shairport-sync -h" to get a list of all mdns_backends. The default is the first one.
//	port = 7000;; // Listen for service requests on this port. 5000 for AirPlay 1, 7000 for AirPlay 2
//	udp_port_base = 6001; // (AirPlay 1 only) start allocating UDP ports from this port number when needed 
//	udp_port_range = 10; // (AirPlay 1 only) look for free ports in this number of places, starting at the UDP port base. Allow at least 10, though only three are needed in a steady state.
//
//	drift_tolerance_in_seconds = 0.002; // allow a timing error of this number of seconds of drift away from exact synchronisation before attempting to correct it
//	resync_threshold_in_seconds = 0.050; // a synchronisation error greater than this number of seconds will cause resynchronisation; 0 disables it

	playback_mode = "mono"; // This can be "stereo", "mono", "reverse stereo", "both left" or "both right". Default is "stereo".
//	alac_decoder = "hammerton"; // This can be "hammerton" or "apple". This advanced setting allows you to choose
//		the original Shairport decoder by David Hammerton or the Apple Lossless Audio Codec (ALAC) decoder written by Apple.
//		If you build Shairport Sync with the flag --with-apple-alac, the Apple ALAC decoder will be chosen by default.

//	ignore_volume_control = "yes"; // set this to "yes" if you want the volume to be at 100% no matter what the source's volume control is set to.
//	volume_range_db = 60 ; // use this advanced setting to set the range, in dB, you want between the maximum volume and the minimum volume. Range is 30 to 150 dB. Leave it commented out to use mixer's native range.
//	volume_max_db = 0.0 ; // use this advanced setting, which must have a decimal point in it, to set the maximum volume, in dB, you wish to use.
//		The setting is for the hardware mixer, if chosen, or the software mixer otherwise. The value must be in the mixer's range (0.0 to -96.2 for the software mixer).
//		Leave it commented out to use mixer's maximum volume.
//	volume_control_profile = "standard" ; // use this advanced setting to specify how the airplay volume is transferred to the mixer volume.
//		"standard" makes the volume change more quickly at lower volumes and slower at higher volumes.
//		"flat" makes the volume change at the same rate at all volumes.
//	volume_control_combined_hardware_priority = "no"; // when extending the volume range by combining the built-in software attenuator with the hardware mixer attenuator, set this to "yes" to reduce volume by using the hardware mixer first, then the built-in software attenuator.
//	run_this_when_volume_is_set = "/full/path/to/application/and/args"; //	Run the specified application whenever the volume control is set or changed.
//		The desired AirPlay volume is appended to the end of the command line â€“ leave a space if you want it treated as an extra argument.
//		AirPlay volume goes from 0 to -30 and -144 means "mute".

//	audio_backend_latency_offset_in_seconds = 0.0; // This is added to the latency requested by the player to delay or advance the output by a fixed amount.
//		Use it, for example, to compensate for a fixed delay in the audio back end.
//		E.g. if the output device, e.g. a soundbar, takes 100 ms to process audio, set this to -0.1 to deliver the audio
//		to the output device 100 ms early, allowing it time to process the audio and output it perfectly in sync.
//	audio_backend_buffer_desired_length_in_seconds = 0.2; // If set too small, buffer underflow occurs on low-powered machines.
//		Too long and the response time to volume changes becomes annoying.
//		Default is 0.2 seconds in the alsa backend, 0.35 seconds in the pa backend and 1.0 seconds otherwise.
//	audio_backend_buffer_interpolation_threshold_in_seconds = 0.075; // Advanced feature. If the buffer size drops below this, stop using time-consuming interpolation like soxr to avoid dropouts due to underrun.
//	audio_backend_silent_lead_in_time = "auto"; // This optional advanced setting, either "auto" or a positive number, sets the length of the period of silence that precedes the start of the audio.
//		The default is "auto" -- the silent lead-in starts as soon as the player starts sending packets.
//		Values greater than the latency are ignored. Values that are too low will affect initial synchronisation.

//	dbus_service_bus = "system"; // The Shairport Sync dbus interface, if selected at compilation, will appear
//		as "org.gnome.ShairportSync" on the whichever bus you specify here: "system" (default) or "session".
//	mpris_service_bus = "system"; // The Shairport Sync mpris interface, if selected at compilation, will appear
//		as "org.gnome.ShairportSync" on the whichever bus you specify here: "system" (default) or "session".

//	resend_control_first_check_time = 0.10; // Use this optional advanced setting to set the wait time in seconds before deciding a packet is missing.
//	resend_control_check_interval_time = 0.25; //  Use this optional advanced setting to set the time in seconds between requests for a missing packet.
//	resend_control_last_check_time = 0.10; // Use this optional advanced setting to set the latest time, in seconds, by which the last check should be done before the estimated time of a missing packet's transfer to the output buffer.
};

// Advanced parameters for controlling how Shairport Sync stays active and how it runs a session
sessioncontrol =
{
//	"active" state starts when play begins and ends when the active_state_timeout has elapsed after play ends, unless another play session starts before the timeout has fully elapsed.
//	run_this_before_entering_active_state = "/full/path/to/application and args"; // make sure the application has executable permission. If it's a script, include the shebang (#!/bin/...) on the first line
//	run_this_after_exiting_active_state = "/full/path/to/application and args"; // make sure the application has executable permission. If it's a script, include the shebang (#!/bin/...) on the first line
//	active_state_timeout = 10.0; // wait for this number of seconds after play ends before leaving the active state, unless another play session begins.

//	run_this_before_play_begins = "/full/path/to/application and args"; // make sure the application has executable permission. If it's a script, include the shebang (#!/bin/...) on the first line
//	run_this_after_play_ends = "/full/path/to/application and args"; // make sure the application has executable permission. If it's a script, include the shebang (#!/bin/...) on the first line

//	run_this_if_an_unfixable_error_is_detected = "/full/path/to/application and args"; // if a problem occurs that can't be cleared by Shairport Sync itself, hook a program on here to deal with it. An error code-string is passed as the last argument.
//	  Many of these "unfixable" problems are caused by malfunctioning output devices, and sometimes it is necessary to restart the whole device to clear the problem.
//	  You could hook on a program to do this automatically, but beware -- the device may then power off and restart without warning!
//	wait_for_completion = "no"; // set to "yes" to get Shairport Sync to wait until the "run_this..." applications have terminated before continuing

//	allow_session_interruption = "no"; // set to "yes" to allow another device to interrupt Shairport Sync while it's playing from an existing audio source
//	session_timeout = 120; // wait for this number of seconds after a source disappears before terminating the session and becoming available again.
};

// Diagnostic settings. These are for diagnostic and debugging only. Normally you should leave them commented out
diagnostics =
{
//	disable_resend_requests = "no"; // set this to yes to stop Shairport Sync from requesting the retransmission of missing packets. Default is "no".
//	log_output_to = "syslog"; // set this to "syslog" (default), "stderr" or "stdout" or a file or pipe path to specify were all logs, statistics and diagnostic messages are written to. If there's anything wrong with the file spec, output will be to "stderr".
//	statistics = "no"; // set to "yes" to print statistics in the log
//	log_verbosity = 0; // "0" means no debug verbosity, "3" is most verbose.
//	log_show_file_and_line = "yes"; // set this to yes if you want the file and line number of the message source in the log file
//	log_show_time_since_startup = "no"; // set this to yes if you want the time since startup in the debug message -- seconds down to nanoseconds
//	log_show_time_since_last_message = "yes"; // set this to yes if you want the time since the last debug message in the debug message -- seconds down to nanoseconds
//	drop_this_fraction_of_audio_packets = 0.0; // use this to simulate a noisy network where this fraction of UDP packets are lost in transmission. E.g. a value of 0.001 would mean an average of 0.1% of packets are lost, which is actually quite a high figure.
//	retain_cover_art = "no"; // artwork is deleted when its corresponding track has been played. Set this to "yes" to retain all artwork permanently. Warning -- your directory might fill up.
};
